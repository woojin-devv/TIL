## 1. 기억해둬야할 python 연산자 

| 연산자  | 설명                    |
| ---- | --------------------- |
| `/`  | 나눗셈: 실수 결과 반환         |
| `//` | 몫 연산: 정수 몫 반환         |
| `%`  | 나머지 연산                |
| `**` | 거듭제곱 (a의 b제곱: `a**b`) |

### 1.2 비트연산
| 연산자 | 설명 |
|--------|------|
| `&`    | 비트 AND: 두 비트가 모두 1이면 1, 아니면 0 |
| `^`    | 비트 XOR: 두 비트가 서로 다르면 1 |
| `~`    | 비트 NOT: 비트를 반전 (0 → 1, 1 → 0) |
| `<<`   | 왼쪽 시프트: 비트를 왼쪽으로 n칸 이동 (곱하기 2^n 효과) |
| `>>`   | 오른쪽 시프트: 비트를 오른쪽으로 n칸 이동 (나누기 2^n 효과) |

### 1.3 데이터의 수정 가능 여부
- 저장되어 있는 데이터에 대해 **수정이 가능한지** 아닌지를 기준으로 나눔
- **Mutable object** → 수정 가능한 객체  
  - 예시: `list`, `set`, `dictionary`
- **Immutable object** → 수정 불가능한 객체  
  - 예시: `int`, `float`, `str`, `tuple`

## 2. 기억해둬야 할 Python 함수

### 2.1 `lambda` (익명 함수, 간단한 합성 함수)

- 한 줄로 정의되는 작은 함수
- 일반 함수 정의 없이도 즉석에서 함수 생성 가능

```python
f = lambda x: x**2 + 2*x + 1
print(f(3))
>> 16
```

### 2.2 append() / insert()

### 2.3 remove() / pop

### 기타 팁
- Python의 내장 `sort()` 함수는 **Timsort** 알고리즘을 사용하며, 시간복잡도는 **O(n log n)**  
- 정렬이 필요한 경우, 가능하면 **내장 `sort()` / `sorted()` 함수**를 사용하자  
  - → 빠르고 안정적이며 대부분의 상황에 최적화되어 있음
- 내장 정렬을 사용할 수 없는 경우 (예: 정렬 조건이 복잡하거나 외부 구현 제한), **퀵 정렬(Quick Sort)** 등의 정렬 알고리즘을 직접 구현해야 함 (퀵 아니면, 기수정렬..나머지 정렬을 비추)
- 리스트 정렬 방식:
  ```python
  lst.sort()        # 제자리 정렬 (in-place), 반환값 없음
  sorted_lst = sorted(lst)  # 원본은 유지, 정렬된 새 리스트 반환
  ```
